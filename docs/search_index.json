[["index.html", "Creaci√≥n de paquetes de R/Bioconductor para el an√°lisis de metagenomas. Bienvenida 0.1 Instructores 0.2 Ayudantes 0.3 Temario 0.4 Patrocinadores 0.5 Licencia", " Creaci√≥n de paquetes de R/Bioconductor para el an√°lisis de metagenomas. Dra. Mirna V√°zquez Rosas-Landa, Dra. Joselyn Cristina Ch√°vez Fuentes, M.C. Erick Cuevas Fern√°ndez Bienvenida Les damos la bienvenida al Workshop Creaci√≥n de paquetes de R/Bioconductor para el an√°lisis de metagenomas! En los √∫ltimos a√±os la metagen√≥mica ha cobrado una gran importancia para el descubrimiento de nuevos grupos microorganismos y rutas metab√≥licas. En este taller revisaremos los m√©todos m√°s recientes para analizar datos metagen√≥micos, usando herramientas de software libre y paquetes de R especializados que est√°n disponibles libremente v√≠a Bioconductor. Durante este taller aprender√°s a reconstruir genomas a partir de metagenomas utilizando diferentes herramientas de software libre y revisaremos diferentes estrategias de binning y predicci√≥n metab√≥lica. Adicionalmente, identificaremos √°reas de oportunidad para el desarrollo de software en metagen√≥mica y aprender√°s los pasos para crear tus propios paquetes para generar herramientas que resuelvan estas problem√°ticas actuales. 0.1 Instructores Dra. Mirna V√°zquez Rosas Landa: Investigadora en el Instituto de Ciencias de Mar y Limnolog√≠a de la UNAM. Dra. Joselyn Cristina Ch√°vez Fuentes: Estancia Postdoctoral en Icahn School of Medicine at Mount Sinai. Dra. Yalbi I. Balderas-Mart√≠nez: Investigadora en el Instituto Nacional de Enfermedades Respiratorias Ismael Cos√≠o Villegas. M.C. Erick Cuevas Fern√°ndez: Estudiante de Doctorado en la Universidad Nacional Aut√≥noma de M√©xico. M.C. Jos√© Antonio Ovando Ric√°rdez: Estudiante de Doctorado en el Instituto Nacional de Enfermedades Respiratorias Ismael Cos√≠o Villegas. 0.2 Ayudantes 0.3 Temario Consulta el calendario de este curso en: https://bit.ly/calendarcdsb2025 D√≠a 1: Estructura general de un paquete Presentaci√≥n a la CDSB. Pl√°tica: La √∫ltima versi√≥n del √°rbol de la vida y la metagen√≥mica. Control de versiones con GitHub y RStudio. Creando la infraestructura de un paquete. D√≠a 2: Documentaci√≥n de un paquete Creando mis primeras funciones. Documentaci√≥n de funciones. Dise√±o de pruebas. Creaci√≥n de vi√±etas. Introducci√≥n a Conda D√≠a 3: Reconstrucci√≥n de genomas El grupo de datos. Mapeo y Binning. Asignaci√≥n taxon√≥mica. D√≠a 4: Reconstrucci√≥n metab√≥lica e inferencia filogen√©tica An√°lisis de v√≠as metab√≥licas. MEBs (Multigenomic Entropy Based Score pipeline ) Proyectos colaborativos de metagenomas. D√≠a 5: Proyectos colaborativos de metagenomas. Presentaci√≥n de proyecto. Clausura. 0.4 Patrocinadores Agradecemos a nuestros patrocinadores: 0.5 Licencia Este material posee una licencia tipo Creative Commons Attribution-ShareAlike 4.0 International License. Para conocer m√°s sobre esta licencia, visite http://creativecommons.org/licenses/by-sa/4.0/ "],["keynote.html", "1 Keynote 1.1 Diapositivas", " 1 Keynote Instructor/a 04 de agosto de 2025 1.1 Diapositivas "],["control-de-versiones-con-github-y-rstudio.html", "2 Control de versiones con GitHub y RStudio 2.1 Diapositivas 2.2 ¬øPor qu√© hacer control de versiones de nuestros proyectos? 2.3 Git 2.4 Recomendaciones para sus proyectos 2.5 Proyectos colaborativos 2.6 GitHub 2.7 Manual de sobreviviencia con Git Y GitHub en RStudio (en caso de ser necesario) 2.8 C√≥mo clonar un repositorio y tener conecci√≥n/permisos para modificarlo? 2.9 Credenciales HTTPS en Cache 2.10 Conectando RStudio con Git y Github. 2.11 GitHub primero, RStudio despu√©s‚Ä¶ 2.12 Rmarkdown en GitHub 2.13 RStudio primero y GitHub tambi√©n 2.14 Proyecto existente, GitHub al final 2.15 Git basics: commands 2.16 Merge conflics 2.17 Merge conflics 2.18 En resumen", " 2 Control de versiones con GitHub y RStudio M.C. Erick Cuevas Fern√°ndez 04 de agosto de 2025 div.color { border-radius: 5px; padding: 20px; margin: 30px 0px 30px;} div.red { background-color:#f67155; } div.orange{ background-color:#f0BB51;} div.pair { display: flex; flex-direction: row; justify-content: center; text-align:center; padding:0px} div.inside { width: 49%; padding: 0px} div.scroll { max-height: 400px; overflow-y: auto; background: #111111; border-radius:5px; padding: 10px; margin: 30px 0px 30px; color: #999999;} div.alert{color:#bd475d; background-color:transparent} Este documento se basa en ‚ÄúHappy Git with R‚Äù de Jenny Bryan, los STAT 545 TAs, Jim Hester https://happygitwithr.com 2.1 Diapositivas 2.2 ¬øPor qu√© hacer control de versiones de nuestros proyectos? ‚úÖ Los proyectos suelen cambiar y crecer. üíæ Es d√≠ficil saber cu√°les fueron todos los cambios a lo largo del tiempo (en especial tiempos largos, hazlo por tu yo del futuro!). ü§î Las colaboraciones se pueden complicar sin un buen control de versiones. üîê Seguridad. 2.3 Git Git es un sistema de control de versiones Git funciona con GitHub, Bitbucket o GitLab ¬øPor qu√© usar Git en vez de solo renombrar los archivos? ‚úÖ‚úÖPor qu√© es mejor tener una filogenia del archivo. Git es un sistema de control de versiones distribuido, gratuito y de c√≥digo abierto, dise√±ado para manejar todo tipo de proyectos, desde los m√°s peque√±os hasta los m√°s grandes, con rapidez y eficiencia. Git es f√°cil de aprender y ocupa poco espacio con un rendimiento rapid√≠simo. Supera a las herramientas SCM como Subversion, CVS, Perforce y ClearCase con caracter√≠sticas como la ramificaci√≥n local barata, las c√≥modas √°reas de preparaci√≥n y los m√∫ltiples flujos de trabajo. 2.3.1 Git vs controles de versi√≥n a mano Con Git cada contribuidor tiene una copia del repositorio central, con todos los archivos y la historia de los cambios por los que han pasado. Excuse me, do you have a moment to talk about version control?, Jennifer Bryan, 2017 ‚ö†Ô∏è NO OLVIDES TENER INSTALADO Git, en caso de que a√∫n no lo hayas instalado, lo puedes descargar en el siguiente enlace https://git-scm.com/downloads. Para conocer la localizaci√≥n y la versi√≥n de Git que tienes en tu computadora, corre el siguiente comando en la terminal: which git y git --version 2.4 Recomendaciones para sus proyectos Dedicar un directorio Es mejor organizarlo en un RStudio Project Hacer un repositorio de Git Trabajen como siempre, solo adem√°s de guardar, recuerden hacer commit De vez en vez hagan push de sus cambios cuando los hayan verificado. 2.5 Proyectos colaborativos GitHub se parece m√°s a un GoogleDoc que a un Word Document. Es f√°cil que los colaboradores hagan cambios y tambi√©n es f√°cil saber qui√©n hizo que. El owner del proyecto puede dar permisos a los diferentes colaboradores. Tambi√©n existen organizaciones, esto puede ser √∫til para manejar los permisos de grupos grandes de colaboraci√≥n. 2.6 GitHub GitHub es una plataforma para guardar proyectos, hace uso de Git. Su principal utilidad es para generar c√≥digo fuente de programas. ‚ö†Ô∏è NO OLVIDES TENER UNA CUENTA EN GITHUB, en caso de que a√∫n no lo hayas hecho, puedes ir la p√°gina de GitHub y seleccionar join. Es indispensable tu usuario para los ejercicios que siguen. Tambi√©n existen otras plataformas como Bitbucked y GitLab, las cuales funcionan de manera similar a GitHub. 2.7 Manual de sobreviviencia con Git Y GitHub en RStudio (en caso de ser necesario) Por cualquier problema con la conexi√≥n entre RStudio y Git, siempre ten en cuenta la ubicaci√≥n de d√≥nde se instal√≥ Git. Puedes usar en la terminal which git (Mac y Linux) O bien usar en la terminal where git (Windows) Recuerda que la terminal (o l√≠nea de comandos √≥ consola √≥ shell √≥ bash) es un programa en tu computadora que funciona para correr otros programas. Desde RStudio puedes abrir la terminal, lo cual es muy conveniente si est√°s trabajando en un proyecto. Puedes abrir una terminal con: Tools &gt; Terminal (abre la terminal dentro del IDE de RStudio) Tools &gt; Shell (abre una terminal externa a RStudio) 2.8 C√≥mo clonar un repositorio y tener conecci√≥n/permisos para modificarlo? Git puede comunicarse con un servidor remoto usando uno de dos protocolos, HTTPS o SSH, y cada protocolo usa credenciales diferentes. La recomendaci√≥n actual de GitHub es usar HTTPS porque es la manera m√°s f√°cil de configurar y tiene operabilidad en multiples redes y plataformas. Es menos probable que HTTPS sea bloqueado por un firewall. Una conexi√≥n HTTPS permite que credential.helper almacene en cach√© su contrase√±a. (por tanto puedes configurar tu usuario y contrase√±a en tu equipo de uso) Es m√°s sencillo acceder a un repositorio desde cualquier lugar, ya que solo necesitas los detalles de tu cuenta (no se requieren claves SSH) para escribir en el repositorio. Usualmente cuando inicies un proyecto colaborativo con GitHub inicializa el ropositorio con un README. Copia el HTTPS URL para clonar el repositorio en la terminal git clone https://github.com/TU-USUARIO/TU-REPOSITORIO.git. 2.9 Credenciales HTTPS en Cache Para usar HTTPS debes crear un token de acceso personal, PAT (PERSONAL ACCESS TOKEN), esa ser√° tu credencial para HTTPS. Es una alternativa al uso de contrase√±as para la autenticaci√≥n en GitHub. Como precauci√≥n de seguridad, GitHub elimina autom√°ticamente los tokens de acceso personales que no se han usado durante un a√±o. ¬øC√≥mo crear un token? Ve a tu perfil de GitHub, dale click a la imagen de perfil (usualmente en la esquina superior derecha), y busca la opci√≥n de settings √≥ configuraci√≥n seg√∫n sea la configuraci√≥n de idioma que tengas. Da click a continuaci√≥n en Developer settings √≥ Par√°metros del desarrollador. En la barra lateral izquierda da click en Tokens de acceso personal. Haz click en Generar un nuevo token. As√≠gna un nombre descriptivo a tu token. Selecciona los alcances o permisos que deseas otorgarle a este token. Para usar tu token para acceder a repositorios desde la l√≠nea de comando, selecciona repo. (Recomendados: repo, user, workflow ) Finalmente haz click en generar token. Listo, copia y pega tu token en el lugar d√≥nde siempre lo puedas volver a copiar, ya que por razones de seguridad, una vez salgas de la p√°gina no podr√°s volver a ver el token. Nota: Preserva tus tokens de la misma manera que tus contrase√±as y no se las reveles a nadie. Una vez que tengas un token, puedes ingresarlo en lugar de tu contrase√±a cuando realices operaciones de Git a trav√©s de HTTPS. El punto final es que una vez configurada una PAT, varios paquetes de R, incluidos usethis y gh, podr√°n trabajar con la API de GitHub en su nombre, de forma autom√°tica. Por lo tanto, una PAT configurada correctamente significa que todo esto funcionar√° a la perfecci√≥n: - Operaciones HTTPS remotas a trav√©s de la l√≠nea de comando Git y, por lo tanto, a trav√©s de RStudio - Operaciones HTTPS remotas a trav√©s del paquete gert R y, por lo tanto, usethis - Operaciones de la API de GitHub a trav√©s del paquete gh R y, por lo tanto, usethis Probar el repositorio Clonado Despu√©s de hacer clone Usa estos comandos para verificar tu repositorio y revisar desde d√≥nde se est√° sincorinzando. cd myrepo ls -la head README.md git remote show origin Probemos haciendo un cambio en el README echo &quot;Something I want to add to the README in my local computer&quot; &gt;&gt; README.md git status Qu√© pas√≥? Ahora tenemos que decirle a git que queremos seguir los cambios de ese archivo Vamos a commit los cambios y luego a subir (push) los mismos a GitHub git add README.md git commit -m &quot;A commit from my local computer&quot; git push Recuerda tu TOKEN!! ¬øC√≥mo crear un token desde R? Puedes ir directamente a la p√°gina de GitHub a la parte para generar tu token de acceso personal mediante la siguiente funci√≥n: usethis::create_github_token() Y con las opciones que se mencionaban anteriormente puedes configurar y crear tu PAT. Si lo que quieres es especificar tu PAT en RStudio, las siguientes funciones te ser√°n √∫tiles: library(gitcreds) gitcreds_set() library(credentials) set_github_pat() Para eliminar credenciales utiliza la funci√≥n credentials::git_credential_forget() 2.9.1 Actividad Ejecuta los c√≥digos y genera tu PAT, recuerda no perderlo! 2.10 Conectando RStudio con Git y Github. Para lo que sigue a continuaci√≥n, deber√≠as tener esto: Tener una cuenta en GitHub R y RStudio actualizados Git instalado Saber que desde la terminal puedes hacer push y pull 2.11 GitHub primero, RStudio despu√©s‚Ä¶ Crea un repositorio en GitHub: mi_repositorio &gt; Public &gt; YES initialize this repository with a README &gt; clicken el gran bot√≥n verde ‚ÄúCreate repository‚Äù En RStudio crea un nuevo proyecto: File &gt; New Project &gt; Version Control &gt; Git. Ahi pega el URL del repositorio https://github.com/mi_usuario/mi_repositorio.git. Da click en Create Project. Esto nos generar√° los siguientes elementos: Un directorio nuevo Un repositorio Git enlazado a al repositorio de GitHub Un proyecto en RStudio Con este procedimiento ya no es necesario preocuparse por configurar controles remotos Git y rastrear ramas en la l√≠nea de comandos. 2.11.1 Actividad Genera un repositorio con el nombre que desees. Y con√©ctalo a RStudio. Cerciorate de que el archivo README se encuentre en tu nueva carpeta. Usa la funci√≥n usethis::use_r(\"titulo_de_un_script\") y observa lo que sucede. PAUSA ¬øC√≥mo comento y doy push/pull desde RStudio? 2.11.2 Comentar, pull y push Con la flecha azul podemos hacer pull (RECUERDA HACERLO ANTES DE HACER UN PUSH), y con la flecha verde un push. Para poder comentar y hacer push debemos marcar con una flechita mediante un click en las peque√±as cajas blancas de la columna Staged, damoc click en commit lo cual no abre la siguiente ventana. Volvemos a dar click en commit, y finalizamos con push (flecha verde). 2.12 Rmarkdown en GitHub Creemos un Rmakrdown y sub√°moslo a GitHub Ahora hay que agregarlo al repositorio (add), stage and commit. Subieron el hmlt? Qu√© tal se ve? No se ve como queremos, verdad? Para eso necesitamos recuperar el .md. El .md es un resultado intermedio de crear el html desde Rmd. Tenemos que cambiar el header para esto --- title: &quot;RmarkwondTest&quot; output: html_document: keep_md: true --- 2.12.1 Actividad Usa el c√≥digo dir.create(\"mis_imagenes\") en la consola de tu sesi√≥n de RStudio (la que est√° vinculada a tu repositorio). Ejecuta el siguiente c√≥digo quitando los #: install.packages(&quot;MASS&quot;) library (MASS) data(MASS::cats) # pdf(&quot;mis_imagenes/cats_plot.pdf&quot;) ggplot(cats, aes(x = Sex)) + geom_bar(fill = &quot;orange&quot;, color = &quot;black&quot;) + theme_classic() + xlab(&quot;Sexo&quot;) + ylab(&quot;N√∫mero de Gatos&quot;) + ggtitle(&quot;Gatos&quot;) # dev.off() Comenta y da push a los cambios que realizaste en el repositorio. 2.13 RStudio primero y GitHub tambi√©n Usa uno de los proyectos que hayas generado en las sesiones anteriores, PERO, que no est√© enlazado a GitHub. Ahora veremos como conectar un proyecto de R existente con GitHub. Realiza los pasos que hicimos en GitHub primero, RStudio despu√©s pero asegurate de crear un repositorio con un nuevo nombre. Y LISTO!! usa un simple ctrl + c, √≥ mv √≥ click derecho + copiar √≥ el m√©todo que prefieras para mover o copiar archivos. Copia los archivos de tu antig√ºo proyecto al proyecto nuevo. Solo haz commit y push y listo, lo que ten√≠a en tu antig√ºo proyecto ya est√° enlazado a GitHub. 2.14 Proyecto existente, GitHub al final Supongamos que tenemos un proyecto de R existente en alg√∫n lugar de nuestra computadora. NOTA: Para generar proyecto de RStudio desde la consola puedes utilizar el siguiente c√≥digo: usethis::create_project() O en RStudio con File &gt; New Project &gt; Existing Directory Si su proyecto ya es un proyecto de RStudio, ejec√∫telo. ¬øYa es un repositorio de Git? La presencia del panel de Git deber√≠a alertarlo. Si es as√≠, ha terminado. Sino este es el primer camino a seguir: Con el p√°quete usethis usa la funci√≥n usethis::use_git En RStudio ve a Tools &gt; Project Options &gt; Git/SVN. Dentro de Version control system, selecciona Git. Y da click a ‚ÄúYes‚Äù cuando aparezca ‚ÄúConfirm New Git Repository?‚Äù. Si usaste RStudio o usethis, el proyecto deber√≠a reiniciarse en RStudio. Hazlo tu mismo si hizo git init. RStudio ahora deber√≠a tener un panel Git. 2.14.1 Breviario cultural con los PATs Si usas el paquete usethis Y has configurado un token de acceso personal (PAT) de GitHub has esto en R: usethis::use_github() Esto crear√° un nuevo repositorio en GitHub, lo agregar√° como un control remoto, configurar√° una rama de seguimiento y lo abrir√° en su navegador. Lea la ayuda de use_github() para conocer sus argumentos y consejos sobre c√≥mo configurar una PAT. Esto es extremadamente √∫til para una variedad de flujos de trabajo que llaman a la API de GitHub. Considere configurar esto si usa usethis, devtools o gh con regularidad. Volviendo al tema de Proyecto existente, GitHub al final. Otra opci√≥n que se puede hacer para conectar un proyecto existen a GitHub es ir a hacer un repositorio a GitHub PERO ten en cuenta los siguientes cambios: Elije un nombre de repositorio; probablemente deber√≠a coincidir con el nombre de su proyecto y directorio local. NO inicialice este repositorio con un archivo README. Todo lo dem√°s es igual a los pasos que hac√≠amos en GitHub primero, RStudio despu√©s‚Ä¶ Ahora ve a tu proyecto de RStudio, has clic en los ‚Äúdos cuadros de color p√∫rpura y un cuadrado blanco‚Äù en el panel de Git. Has clic en ‚ÄúAgregar control remoto‚Äù. Pegue la URL aqu√≠ y elija un nombre remoto, casi con certeza el origin. Ahora ‚ÄúADD‚Äù. Pasado esto deberiamos volver en el cuadro de di√°logo ‚ÄúNew Branch‚Äù. Ingresa ‚Äúmaster‚Äù como el nombre de la rama y aseg√∫rate de que la opci√≥n ‚ÄúSync branch with remote‚Äù est√© marcada. Haz clic en ‚ÄúCreate‚Äù. En el siguiente cuadro de di√°logo elije ‚Äúoverwrite‚Äù. Ahora solo haz commit/pull/push y c√©rciorate que FUNCIONE!! 2.15 Git basics: commands Fetch Commits git fetch Create and Switch to a branch git branch [branch-name] git checkout [branch-name] 2.16 Merge conflics A veces, no tan a veces tambi√©n, las cosas no salen bien a la primera Merging (Fusionar) es una de esas cosas Cuando bajamos un cambio o fusionamos branches esto puede pasar. Primera regla: NO ENTRAR EN PANICO!!! Revisen el status del repositorio. Qu√© archivo tiene conflicto? 2.17 Merge conflics Abran ese archivo y busquen los problemas de merge. Es f√°cil, se ven as√≠: &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html &lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt; ======= &lt;div id=&quot;footer&quot;&gt; please contact us at support@github.com &lt;/div&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; issue-5:index.html Editen esa secci√≥n, dejen una versi√≥n final. Hagan commit y push Si entran en p√°nico? Aborten la misi√≥n! git merge --abort t 2.18 En resumen ¬°QUE LA FUERZA TE ACOMPA√ëE! "],["creando-la-infraestructura-de-un-paquete.html", "3 Creando la infraestructura de un paquete 3.1 Diapositivas 3.2 Los primeros pasos 3.3 Checks 3.4 Modificando el archivo DESCRIPTION 3.5 Modificando el archivo NEWS", " 3 Creando la infraestructura de un paquete Joselyn Cristina Ch√°vez Fuentes 04 de agosto de 2025 3.1 Diapositivas 3.2 Los primeros pasos Revisar si podemos usar el nombre del paquete available::available(&quot;mipaquete&quot;) Crear la estructura inicial del paquete usethis::create_package(&quot;mipaquete&quot;) Podemos agregar la estructura de biocthis biocthis::use_bioc_pkg_templates() Pedir que Git ignore el archivo .Rproj usethis::use_git_ignore(&quot;*.Rproj&quot;) Crear el respositorio de GitHub usethis::use_github() Crear el archivo Description estilo Bioconductor biocthis::use_bioc_description() Crear el archivo README estilo Bioconductor biocthis::use_bioc_readme_rmd() devtools::build_readme() Recuerda guardar los cambios, hacer commit y push. Crear el archivo NEWS estilo Bioconductor biocthis::use_bioc_news_md() Crear los archivos de ayuda para usuarios y contribuidores biocthis::use_bioc_coc() usethis::use_tidy_contributing() biocthis::use_bioc_support() biocthis::use_bioc_issue_template() biocthis::use_bioc_citation() 3.3 Checks 3.3.1 BiocCheck BiocManager::install(&quot;BiocCheck&quot;) BiocCheck::BiocCheck() Algunas reglas de BiocCheck: Utilizar el s√≠mbolo &lt;- en lugar de = para definir funciones y variables. Utilizar TRUE y FALSE en lugar de T y F. Indentar el c√≥digo usando 4 espacios. Las l√≠neas de c√≥digo y documentaci√≥n no deben ser mayores a 80 caracteres. Las funciones deben tener 50 l√≠neas de c√≥digo o menos. El paquete debe contener al menos una vi√±eta. Al menos 80% de las funciones deben tener ejemplos reproducibles. Las dependencias deben ser declaradas en el archivo DESCRIPTION. El paquete debe tener al menos un biocView. El tama√±o del paquete no debe ser mayor 5Mb. El maintainer debe estar suscrito a la lista de correo de Bioconductor. El maintainer debe agregar su paquete en los tags de Bioconductor. 3.3.2 rcmdcheck install.packages(&quot;rcmdcheck&quot;) rcmdcheck::rcmdcheck() Algunas reglas de rcmdcheck: El paquete debe ser instalable. Los ejemplos de las funciones deben ser reproducibles. Las vi√±etas deben ser reproducibles. Todas las unidades de prueba deben pasar sin errores. El archivo DESCRIPTON debe tener el formato adecuado. 3.4 Modificando el archivo DESCRIPTION Paquete Este es el nombre del paquete. El nombre del repositorio y el nombre del paquete en la descripci√≥n deben coincidir (incluyendo may√∫sculas y min√∫sculas). T√≠tulo Este es un t√≠tulo breve pero descriptivo para el paquete. Versi√≥n Todos los paquetes de Bioconductor utilizan un esquema de versi√≥n x.y.z. Cuando se env√≠a por primera vez a Bioconductor, un paquete debe tener la versi√≥n 0.99.0. Se aplican las siguientes reglas: x es normalmente 0 para paquetes que a√∫n no han sido liberados. y es par para paquetes liberados, e impar para paquetes en desarrollo. Generalmente, no se debe aumentar este n√∫mero en el pre-release. z se incrementa siempre que se realizan cambios en el paquete. Descripci√≥n La descripci√≥n debe ser una visi√≥n general relativamente breve pero detallada de lo que implica la funcionalidad del paquete. Debe ser de al menos tres oraciones completas. Autores Se requiere una designaci√≥n de maintainer (cre) con una direcci√≥n de correo electr√≥nico que se mantenga activamente. Esta direcci√≥n de correo se utilizar√° para el contacto con respecto a cualquier problema que surja con el paquete en el futuro. Idealmente, se debe incluir el ORCiD por lo menos del maintainer. person(&quot;Lori&quot;, &quot;Shepherd&quot;, email = Lori.Shepherd@roswellpark.org, role = c(&quot;cre&quot;, &quot;aut&quot;), comment = c(ORCID = &quot;0000-0002-5910-4010&quot;)) S√≥lo debe figurar una persona como responsable para garantizar un √∫nico punto de contacto. Esta persona tendr√° acceso al repositorio git en git.bioconductor.org. El acceso a Commit puede ser dado a otros desarrolladores por solicitud en la lista de correo bioc-devel. Otra opci√≥n es a√±adir colaboradores al repositorio de GitHub. Este enfoque permite el desarrollo por muchos pero restringe el acceso a git.bioconductor.org. Licencia El campo de licencia debe referirse preferentemente a una licencia est√°ndar no restrictiva. Las licencias que restringen el uso, por ejemplo, a investigadores acad√©micos o sin fines de lucro, no son adecuadas para Bioconductor. Los paquetes de bioconductor b√°sico suelen estar licenciados bajo Artistic-2.0. El paquete debe contener s√≥lo c√≥digo que pueda ser redistribuido de acuerdo con la licencia del paquete. LazyData Para paquetes que incluyen datos, se recomienda NO incluir LazyData: TRUE. Incluirlo en ese caso, ralentiza la carga de paquetes con datos grandes. Dependencias Todos los paquetes deben estar disponibles a trav√©s de biocViews o CRAN de Bioconductor; el uso del campo Remotes: no es soportado, por lo tanto las dependencias s√≥lo disponibles en otros repositorios (e.g.¬†GitHub) no est√°n permitidas. Un paquete puede ser listado s√≥lo una vez entre Depends, Imports, Suggests, o Enhances: Imports: es para paquetes que proporcionan funciones, m√©todos o clases que se usan dentro del c√≥digo del paquete. La mayor√≠a de los paquetes est√°n listados aqu√≠. Depends: es para paquetes que proporcionan funcionalidad esencial para los usuarios del paquete, por ejemplo, el paquete GenomicRanges se enumera en el campo Depends: de GenomicAlignments. Es poco com√∫n que m√°s de tres paquetes aparezcan como Depends:. Suggests: es para paquetes usados en vi√±etas, ejemplos y c√≥digo condicional. Com√∫nmente, los paquetes de anotaciones y experimentos (por ejemplo, TxDb*) usados en vi√±etas y c√≥digo de ejemplo se incluyen en este campo, evitando as√≠ una descarga costosa. Enhances: es para paquetes como parallel que mejoran el rendimiento del paquete, pero no son estrictamente necesarios para su funcionalidad. En el caso de que se requiera una funci√≥n √∫nica externa para el c√≥digo del paquete, la disponibilidad y el uso del paquete pueden hacerse a trav√©s de: if (!requireNamespace(&#39;suggPKG&#39;, quietly = TRUE)) stop(&quot;Install &#39;suggPKG&#39; to use this function.&quot;) suggPKG::function() biocViews Este campo es obligatorio! Especifica al menos dos biocViews. Los t√©rminos deben provenir del mismo tipo de paquete (Software, AnnotationData, ExperimentData o Workflow). Puedes encontrar m√°s informaci√≥n en: https://www.bioconductor.org/packages/release/BiocViews.html BugReports Se recomienda apuntar hacia el repositorio de GitHub, por ejemplo: https://github.com/usuario/paquete/issues. URL Se incluyen los links importantes, como el repositorio con el c√≥digo fuente y el sitio web de pkgdown si se cuenta con √©l. Por ejemplo: https://github.com/usuario/paquete https://usuario.github.io/paquete 3.5 Modificando el archivo NEWS Secciones: New: Nuevas funciones. Bug fixes: Reparaci√≥n de errores en las funciones previas o en la documentaci√≥n. Changes: Cambios en el c√≥digo de las funciones, incluyendo modificaciones en los argumentos. Breaking changes: Cambios importantes que romper√≠an el c√≥digo en caso de no ser atendidos, por ejemplo el uso de funciones o argumentos antiguos. Enhancements: Mejoras a las funciones existentes. Formato El archivo NEWS se ve similar a este ejemplo: "],["creando-mis-primeras-funciones.html", "4 Creando mis primeras funciones 4.1 Diapositivas 4.2 Nombre de la funci√≥n 4.3 Estructura de la funci√≥n 4.4 ¬°Tu turno! 4.5 Argumentos 4.6 ¬°Tu turno! 4.7 Indentaci√≥n 4.8 Uso de espacios 4.9 Comentarios 4.10 Mensajes para el usuario", " 4 Creando mis primeras funciones Instructora: Joselyn Ch√°vez 05 de agosto de 2025 4.1 Diapositivas 4.2 Nombre de la funci√≥n Cortos pero descriptivos Recomendable: Separar las palabras con _ Establecer una palabra en com√∫n al inicio para familias de funciones use_bioc_citation() # es mejor que citation() bioc_cit() usebioccitation() useBiocCitation() use.bioc.citation() 4.3 Estructura de la funci√≥n Indentar las l√≠neas de c√≥digo. Agregar comentarios para separar/describir las secciones importantes. Usar la sintaxis paquete::funcion() cuando hacemos llamado a funciones de otros paquetes. usethis::use_r(&quot;subset_heatmap&quot;) Generemos el c√≥digo de manera regular. Simulemos una matriz con diversas mediciones y grafiquemos los datos en un heatmap. mi_matriz &lt;- matrix(rnorm(100), nrow = 10) rownames(mi_matriz) &lt;- paste0(&quot;medicion_&quot;,letters[1:10]) colnames(mi_matriz) &lt;- paste0(&quot;grupo_&quot;,letters[1:10]) library(ComplexHeatmap) Heatmap(mi_matriz, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) Escribamos una funci√≥n que permita seleccionar algunos grupos de inter√©s y genere el heatmap. No la mejor opci√≥n: library(ComplexHeatmap) subset_heatmap &lt;- function(x,mediciones=NULL,grupos=NULL) { x_subset &lt;- x[mediciones,grupos] Heatmap(mi_matriz, cluster_columns=FALSE, heatmap_legend_param=list(title=&quot;valores&quot;)) } Un poco mejor: library(ComplexHeatmap) subset_heatmap &lt;- function(x, mediciones = NULL, grupos = NULL) { x_subset &lt;- x[mediciones,grupos] Heatmap(mi_matriz, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) } Mucho mejor: subset_heatmap &lt;- function(x, mediciones = NULL, grupos = NULL) { # subset matrix x_subset &lt;- x[mediciones, grupos] # plot heatmap ComplexHeatmap::Heatmap( x_subset, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) } Ejecutemos la funci√≥n: subset_heatmap( mi_matriz, mediciones = c(&quot;medicion_a&quot;, &quot;medicion_b&quot;, &quot;medicion_c&quot;), grupos = c(&quot;grupo_d&quot;,&quot;grupo_e&quot;,&quot;grupo_f&quot;)) 4.4 ¬°Tu turno! Escribe una funci√≥n que: Filtre la matriz y mantenga s√≥lo los valores por encima de cierto valor. Genere el heatmap filtrado. Recuerda seguir las recomendaciones para escribir funciones. 4.5 Argumentos Los argumentos deben tener un nombre descriptivo y bien documentado. No la mejor opci√≥n: subset_heatmap &lt;- function(x, m, g) { # subset matrix x_subset &lt;- x[mediciones, grupos] } Una mejor opci√≥n: subset_heatmap &lt;- function(x, mediciones, grupos) { # subset matrix x_subset &lt;- x[mediciones, grupos] # plot heatmap ComplexHeatmap::Heatmap( x_subset, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) } Los argumentos generalmente deben tener valores default. subset_heatmap &lt;- function(x, mediciones = NULL, grupos = NULL, return_plot = TRUE) { # subset matrix x_subset &lt;- x[mediciones, grupos] # plot heatmap ComplexHeatmap::Heatmap( x_subset, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) } Eval√∫a la validez de los argumentos subset_heatmap &lt;- function(x, mediciones = NULL, grupos = NULL, return_plot = TRUE) { stopifnot(is.matrix(x)) # subset matrix x_subset &lt;- x[mediciones, grupos] # plot heatmap heatmap &lt;- ComplexHeatmap::Heatmap( x_subset, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) if(return_plot == TRUE) {return(heatmap)} } Este c√≥digo no debe funcionar: subset_heatmap( as.data.frame(mi_matriz), mediciones = c(&quot;medicion_a&quot;, &quot;medicion_b&quot;, &quot;medicion_c&quot;), grupos = c(&quot;grupo_d&quot;,&quot;grupo_e&quot;,&quot;grupo_f&quot;)) Nota: Usa las funciones is() para evaluar la clase de los objects, no uses class() == ni class() !=. Proporciona pistas para entender los errores. subset_heatmap &lt;- function(x, mediciones = NULL, grupos = NULL, return_plot = TRUE) { if(!is.matrix(x)) {stop(&quot;x debe ser una matriz&quot;)} # subset matrix x_subset &lt;- x[mediciones, grupos] # plot heatmap heatmap &lt;- ComplexHeatmap::Heatmap( x_subset, cluster_columns = FALSE, heatmap_legend_param = list(title = &quot;valores&quot;)) if(return_plot == TRUE) {return(heatmap)} } Este c√≥digo debe dar un error, m√°s un mensaje de ayuda. subset_heatmap( as.data.frame(mi_matriz), mediciones = c(&quot;medicion_a&quot;, &quot;medicion_b&quot;, &quot;medicion_c&quot;), grupos = c(&quot;grupo_d&quot;,&quot;grupo_e&quot;,&quot;grupo_f&quot;)) 4.6 ¬°Tu turno! Agrega pasos de evaluaci√≥n para los otros argumentos de la funci√≥n. Incluye mensajes de ayuda cuando el formato de los argumentos no es el esperado. 4.7 Indentaci√≥n Usa 4 espacios para indentar, evita los tabs. No uses l√≠neas de m√°s de 80 caracteres. 4.8 Uso de espacios Usa un espacio despu√©s de la coma: a, b, c. Usa espacio despu√©s de operadores binarios: a == b. 4.9 Comentarios Usa ‚Äú##‚Äù para comenzar las l√≠neas de comentarios. Los comentarios deben usarse como notas y documentaci√≥n solamente. No dejes c√≥digo comentado que no se va a usar. Evita los TODO‚Äôs comentados cuando vayas a publicar el paquete. 4.10 Mensajes para el usuario Si deseas imprimir mensajes para el usuario, como el progreso del an√°lisis en la funci√≥n o advertir sobre los valores de los argumentos, evita el uso de cat(), mejor usa: message() comunica mensajes diagn√≥stico, como el progreso de la funci√≥n. message(&quot;Paso 1: completo&quot;) ## Paso 1: completo warning() comunica situaciones inusuales que pueden ser manejadas por tu c√≥digo. warning(&quot;El n√∫mero de elementos esperados es mayor a uno, se tomar√° el primer valor del vector&quot;) ## Warning: El n√∫mero de elementos esperados es mayor a uno, se tomar√° el ## primer valor del vector stop() indica una condici√≥n err√≥nea. stop(&quot;x debe ser num√©rico&quot;) "],["documentaci√≥n-de-funciones.html", "5 Documentaci√≥n de funciones 5.1 Diapositivas 5.2 Links importantes: 5.3 ¬øQu√© es la documentaci√≥n de una funci√≥n y por qu√© es importante? 5.4 Generacion de la documentacion con ayuda del paquete roxygen 5.5 Antes de empezar‚Ä¶‚úèÔ∏è 5.6 Generacion de un bloque de documentacion con ayuda del paquete roxygen. 5.7 Otros campos de la documentacion.", " 5 Documentaci√≥n de funciones Instructor/a: 05 de agosto de 2025 5.1 Diapositivas 5.2 Links importantes: Esta lecci√≥n est√° basada en algunos manuales sobre documentaci√≥n: Una vi√±eta del cranproject El manual de paqutes de r En esta vi√±eta de cranproject 5.3 ¬øQu√© es la documentaci√≥n de una funci√≥n y por qu√© es importante? üôáÔ∏è Es la informaci√≥n complementaria que el desarrollador escribe sobre una funci√≥n y que se accede con ? seguido el nombre de una funci√≥n actual de un paquete p.ej. ?unafuncion. üìÅ La documentaci√≥n se almacena como un archivo .Rd (‚ÄúR documentation) en la carpeta man/. üîé La documentaci√≥n usa una s√≠ntesis especial, que es distinta a la de r y que est√° ligeramente basada en LaTeX. üìÑ Se puede renderizar como html, pdf o texto sin formato seg√∫n se necesite. 5.4 Generacion de la documentacion con ayuda del paquete roxygen En un paquete de r y en cualquier ecosistema de devtools no editamos un documento .Rd manualmente. La documentaci√≥n usa una s√≠ntesis parecida a LaTex que puede ser f√°cil de estropear. Por ventaja existen paquetes como roxigen2. Usar roxigen nos permite usar comentarios especiales sobre el inicio de la funci√≥n, esto nos da un par de ventajas: ‚úÖ La documentaci√≥n y la funci√≥n estar√°n en un mismo lugar, por lo que si editas la funci√≥n ser√° mas f√°cil recordar actualizar la documentcion tambi√©n. üéâ Puedes usar markdown en lugar de la s√≠ntesis especial para los archivos .Rd 5.5 Antes de empezar‚Ä¶‚úèÔ∏è Vamos a crear un funci√≥n para nuestro paquete. Supongamos que para nuestro paquete necesitamos una funci√≥n que calcule la moda. Esta es una forma sencilla de calcular la moda: getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } unique(serievector): Crea un vector que contiene √∫nicamente los valores √∫nicos de la serie de n√∫meros serievector. match(serievector, uniqv): Encuentra la posici√≥n de cada valor de serievector en el vector √∫nico uniqv. tabulate(match(serievector, uniqv)): Cuenta cu√°ntas veces aparece cada valor en la serie serievector. which.max(tabulate(match(serievector, uniqv))): Encuentra el √≠ndice del valor m√°ximo en el vector de frecuencias. uniqv[which.max(tabulate(match(serievector, uniqv)))]: Devuelve el valor correspondiente al √≠ndice calculado, que es la moda. Creamos un ejemplo para ver que funcione: serie_numeros &lt;- c(1, 2, 2, 2, 2, 3, 3, 4, 4, 4) resultado &lt;- getmode(serie_numeros) print(resultado) ## [1] 2 Bien ahora si podemos podemos empezar a usar el paquete de roxygen para documentar nuestra funci√≥n.. comencemos. 5.6 Generacion de un bloque de documentacion con ayuda del paquete roxygen. Podemos insertar un esqueleto de comentarios de roxygen para ver su s√≠ntesis. Colocamos el cursor en alg√∫n lugar de la definici√≥n de nuestra funci√≥n y buscamos en la pesta√±a C√≥digo &gt; Insertar Roxygen Skeleton. #&#39; Title #&#39; #&#39; @param serievector #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Ahora ya tenemos un esqueleto de la documentaci√≥n que nos da una ventaja para su creaci√≥n. Las l√≠neas de comentarios de Roxygen siempre comienzan con #', el habitual para un comentario # mas un ' Veamos los comentarios de uno por uno: Empezamos con el titulo. Se sugiere poner en el titulo las acciones principales que realiza la funci√≥n en este caso por ejemplo podremos usar: #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @param serievector #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Muy bien!. El siguiente comentario que podemos ver es @param. Pero antes, vamos a a√±adir una peque√±a descripci√≥n de la funci√≥n y como usarla. Primero a√±adimos la peque√±a descripci√≥n con @description: #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; @param serievector #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Ahora vamos a a√±adir el comentario @usage que nos indica como puedes mandar a llamar la funci√≥n. #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; @usage getmode(serievector) #&#39; @param serievector #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Ahora si vamos a a√±adir una peque√±a descripci√≥n de nuestros argumentos. Si tuvi√©ramos mas de un par√°metro en nuestra funci√≥n podr√≠amos llamar las veces que sea necesario el comentario de par√°metro con @param, veamoslo. Ahora a√±adimos una peque√±a descripci√≥n a nuestro √∫nico par√°metro que es serievector: #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; #&#39; @param serievector Es una serie de n√∫meros en forma de un vector simple de r. #&#39; #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Despu√©s, podemos a√±adir un comentario de detalles de la funci√≥n con @details. Por ejemplo, si en nuestro ejemplo tuvi√©ramos ciertos valores no num√©ricos en nuestro vector de entrada, por ejemplo letras, ¬ønuestra funci√≥n podr√≠a leerlas?, o si le di√©ramos un vector sin caracteres ¬øque pasar√≠a?, veamos: serie_numeros &lt;- c(0,2,2,&quot;d&quot;, &quot;d&quot;,&quot;d&quot;) resultado &lt;- getmode(serie_numeros) print(resultado) ## [1] &quot;d&quot; serie_numeros &lt;- c() resultado &lt;- getmode(serie_numeros) print(resultado) ## NULL Entonces, esto es un ejemplo de lo que podr√≠amos poner en el comentario @details. Hagamoslo describiendo esto. En details podemos agregar detalles un poco mas espec√≠ficos que en la descripci√≥n de la funci√≥n #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; #&#39; @param serievector Es una serie de n√∫meros en forma de un vector simple de r. #&#39; #&#39; @details si tu vector de entrada puede ser interpretado alternando n√∫meros y #&#39; letras escritas entre comillas &quot;&quot;. Si un vector esta vac√≠o, dar√° como #&#39; resultado un NULL. #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Ya casi terminamos de llenar nuestra documentaci√≥n, pero antes vamos a ver algunos otros arrobas que pudieran ser importantes. El @import e @importfrom importan funciones de otros paquetes en caso de que las necesitemos, el primero importa todas las funciones del paquete que que solicites, y el segundo importa solo algunas funciones especificas. En nuestra funci√≥n no necesitamos llamar funciones de otros paquetes puesto que todas las que usamos est√°n en r base. Pero imaginemos que tu funci√≥n, por ejemplo necesita leer un archivo .tsv con la funci√≥n read_tsv del paquete readr y despu√©s reconvertir la tabla resultante en un archivo con write.table pero solo necesitas esa funci√≥n del paquete utils, entonces har√≠amos: #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; #&#39; @param serievector Es una serie de n√∫meros en forma de un vector simple de r. #&#39; #&#39; @details si tu vector de entrada puede ser interpretado alternando n√∫meros y #&#39; letras escritas entre comillas &quot;&quot;. Si un vector esta vac√≠o, dar√° como #&#39; resultado un NULL. #&#39; @import readr #&#39; @importFrom utils write.table #&#39; @return #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } As√≠ podemos importar las funciones que necesitemos de otros paquetes y se incluir√°n en la documentaci√≥n y se cargaran autom√°ticamente al cargar tu paquete. :eyes::exclamation: Para un correcto funcionamiento de tu paquete y al estar los paquetes necesarios incluidos en la documentaci√≥n, no ser√° necesario llamarlos de la forma ``library(‚Äúapackage‚Äù)```. Entonces llegamos a la secci√≥n @return. Esta descripci√≥n le servir√° al usuario del paquete para conocer cual sera el resultado de la funci√≥n, que puede ser un archivo, una tabla, un numero,etc. Entonces retomando la funci√≥n que usamos al inicio, vamos a escribir una descripci√≥n corta del resultado de la funci√≥n getmode(). #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; #&#39; @param serievector Es una serie de n√∫meros en forma de un vector simple de r. #&#39; #&#39; @details si tu vector de entrada puede ser interpretado alternando n√∫meros y #&#39; letras escritas entre comillas &quot;&quot;. Si un vector esta vac√≠o, dar√° como #&#39; resultado un NULL. #&#39; @return El car√°cter con mas frecuencia de el vector de entrada. #&#39; @export #&#39; #&#39; @examples getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Por ultimo tenemos @export que es el encargado de renderizar la documentaci√≥n para que pueda aparecer en la ventana de Ayuda (abajo a la derecha). esta opci√≥n la dejamos para funciones principales que el usuario va a utilizar, aunque puede que existan alguna funciones internas que no queremos que el usuario vea. En ese caso vamos a usar @noRd en lugar de este. Antes de terminar podemos incluir ejemplos de como funciona nuestra funci√≥n para un mejor entendimiento, pongamos los que ya realizamos: #&#39; @title Encontrar la Moda de una Serie de N√∫meros #&#39; #&#39; @description Esta funci√≥n lee una serie de n√∫meros en forma de vector y #&#39; encuentra el elemento que mas se repite, es decir la moda. #&#39; #&#39; @param serievector Es una serie de n√∫meros en forma de un vector simple de r. #&#39; #&#39; @details si tu vector de entrada puede ser interpretado alternando n√∫meros y #&#39; letras escritas entre comillas &quot;&quot;. Si un vector esta vac√≠o, dar√° como #&#39; resultado un NULL. #&#39; @return El car√°cter con mas frecuencia de el vector de entrada. #&#39; @export #&#39; #&#39; @examples #&#39; serie_n√∫meros &lt;- c(1, 2, 2, 2, 2, 3, 3, 4, 4, 4) #&#39; resultado &lt;- getmode(serie_n√∫meros) #&#39; print(resultado) getmode &lt;- function(serievector) { uniqv &lt;- unique(serievector) uniqv[which.max(tabulate(match(serievector, uniqv)))] } Ahora si, una vez teniendo listo el bloque de comentarios para la documentaci√≥n, vamos a ejecutar devtools::load_all() para cargar nuestras funciones y hecho esto, ejecutamos devtools::document() o presionamos Ctrl/Cmd + Shift + D para convertir los comentarios en archivo .Rd y poder renderizarlo. üíØ Listo, tenemos nuestra documentaci√≥n para una funci√≥n. As√≠ se ver√° cuando el paquete est√© terminado. 5.7 Otros campos de la documentacion. @seealso para indicar funciones relacionadas y facilitar la b√∫squeda de funciones. @references a√±ade algunas referencias. @author para especificar el autor de la funci√≥n. "],["dise√±o-de-pruebas.html", "6 Dise√±o de pruebas 6.1 Diapositivas", " 6 Dise√±o de pruebas Mirna V√°zquez Rosas-Landa 05 de agosto de 2025 6.1 Diapositivas "],["creaci√≥n-de-vi√±etas.html", "7 Creaci√≥n de vi√±etas 7.1 ¬øQu√© es una vi√±eta/vignette? üìù‚ú® 7.2 Caracter√≠sticas de una vignette üåü 7.3 ¬øC√≥mo consultar la vi√±eta de un paquete? ‚ùìüîç 7.4 ¬øC√≥mo crear una vi√±eta? ‚ùìüîç 7.5 ¬øC√≥mo guardar y actualizar la vi√±eta? üîÑüíª 7.6 Veamos un ejemplo üîçüë®‚Äçüíª 7.7 Actividad", " 7 Creaci√≥n de vi√±etas Jos√© Antonio Ovando Ric√°rdez 05 de agosto de 2025 div.color { border-radius: 5px; padding: 20px; margin: 30px 0px 30px;} div.red { background-color:#f67155; } div.orange{ background-color:#f0BB51;} div.pair { display: flex; flex-direction: row; justify-content: center; text-align:center; padding:0px} div.inside { width: 49%; padding: 0px} div.scroll { max-height: 400px; overflow-y: auto; background: #111111; border-radius:5px; padding: 10px; margin: 30px 0px 30px; color: #999999;} div.alert{color:#bd475d; background-color:transparent} 7.1 ¬øQu√© es una vi√±eta/vignette? üìù‚ú® Es una gu√≠a extendida sobre c√≥mo funciona el paquete. Es recomendable que muestre c√≥mo utilizar las funciones del paquete, aplicado en un flujo de trabajo; por ejemplo: el an√°lisis estad√≠stico de una encuesta üìä o el an√°lisis de expresi√≥n diferencial de genes. Podemos estructurarlo como har√≠amos con la escritura de un cap√≠tulo de libro o de un art√≠culo cient√≠fico: debe mostrar el problema a resolver y la metodolog√≠a paso a paso sobre c√≥mo el paquete lo resuelve. Si el paquete contiene funciones que se complementan entre s√≠ para alcanzar un fin espec√≠fico, entonces debes mostrar su uso de forma compartamentalizada. 7.2 Caracter√≠sticas de una vignette üåü Debe mostrar un flujo de an√°lisis explotando el potencial de tu paquete üìäüöÄ. Implementa tantas funciones de tu paquete como sea posible, pero no es necesario que incluya todas üõ†Ô∏è‚ú®. Los datos a usar deben ser peque√±os o f√°ciles de acceder üìÇüîç. Puedes crear m√∫ltiples vi√±etas para mostrar diferentes casos de an√°lisis y cubrir una mayor cantidad de funciones üìùüìö. 7.3 ¬øC√≥mo consultar la vi√±eta de un paquete? ‚ùìüîç browseVignettes(package = &quot;ggplot2&quot;) 7.4 ¬øC√≥mo crear una vi√±eta? ‚ùìüîç biocthis::use_bioc_vignette(&quot;mi_vignette&quot;) Esta funci√≥n tendr√° tres efectos ‚ú®: Generar el directorio vignettes en caso que no exista üìÇüîß. Agregar dependencias en el archivo DESCRIPTION (por ejemplo, knitr necesario para construir vi√±etas dentro del paquete) üìÑüì¶. Abrir un template en formato .Rmd para comenzar a escribir la vi√±eta, que se va a guardar en vignettes/mi_vignette.Rmd üìùüíæ. 7.5 ¬øC√≥mo guardar y actualizar la vi√±eta? üîÑüíª Una vez que se ha generado el archivo vignettes/mi_vignette.Rmd, se hacen las modificaciones necesarias. Puedes usar el comando: edit_file(&quot;vignettes/mi_vignette.Rmd&quot;) Para guardar los cambios, debes hacer clic en el bot√≥n Knit o utiliza la combinaci√≥n de teclas Ctrl/Cmd-Shift-K üíæ‚ú®. 7.6 Veamos un ejemplo üîçüë®‚Äçüíª Busca la vi√±eta del paquete regutools en la p√°gina de Bioconductor üåê: Vi√±eta de regutools en Bioconductor üì¶üìÑ 7.7 Actividad 7.7.1 Ejercicio 1: Identificaci√≥n de vi√±etas en paquetes de inter√©s en Bioconductor üìöüîç En equipos selecciona dos paquetes almacenados en Bioconductor que sean de tu inter√©s y responde las siguientes preguntas: ¬øAmbos paquetes incluyen vi√±etas? üìù‚ùì ¬øQu√© aspectos de la vi√±eta del paquete A versus el paquete B te llaman m√°s la atenci√≥n? üîçü§î ¬øConsideras que alguna vi√±eta est√° mejor desarrollada que la otra? Explica por qu√© üí≠üìä. 7.7.2 Ejercicio 2: Creaci√≥n de vi√±etas en R üõ†Ô∏èüìÑ Pasos: Cargar los paquetes necesarios library(usethis) library(biocthis) Crear un nuevo paquete de R (si no tienes uno ya creado) usethis::create_package(&quot;CDSB2024&quot;) Configurar el paquete para Bioconductor Ejecuta el siguiente comando para configurar el paquete con las mejores pr√°cticas de Bioconductor: biocthis::use_bioc_pkg_templates() Esto agregar√° varios archivos de configuraci√≥n y plantillas √∫tiles para trabajar con Bioconductor. Crear una vi√±eta con biocthis Ejecuta el siguiente comando para agregar una vi√±eta en formato R Markdown. Cambia ‚Äúmi_vignette‚Äù por el t√≠tulo de la vi√±eta que prefieran. usethis::use_vignette(&quot;mi_vignette_usethis&quot;) biocthis::use_bioc_vignette(&quot;mi_vignette_biocthis&quot;) Esto crear√° un archivo R Markdown en la carpeta vignettes/ dentro del paquete. Editar la vi√±eta Abre el archivo creado en vignettes .Rmd. Incluye contenido que describa una funci√≥n del paquete. Abrir la vi√±eta en el navegador y renderiza el archivo .Rmd browseVignettes(&quot;CDSB2024&quot;) 7.7.3 Preguntas de Reflexi√≥n ü§îüí≠ ¬øCu√°l es la ventaja de documentar ejemplos de uso en una vi√±eta? üìö‚ú® ¬øQu√© estructura consideras √∫til para presentar ejemplos en una vi√±eta? üèóÔ∏èüîç ¬øC√≥mo aplicar√≠as esta clase en tu proyecto colaborativo? ü§ùüìà "],["introducci√≥n-a-conda..html", "8 Introducci√≥n a Conda. 8.1 ¬øQu√© es conda? 8.2 conda 101", " 8 Introducci√≥n a Conda. @zorbax 05 de agosto de 2025 8.1 ¬øQu√© es conda? De acuerdo a la definici√≥n oficial: conda: A package manager helps you find and install packages. Entonces, es un gestor/instalador de paquetes. Se obtiene mediante Anaconda o Miniconda. La instalaci√≥n depender√° del sistema operativo a utilizar. Aunque conda est√° disponible para Windows, macOS y Linux, no todos los paquetes disponibles para bioinform√°tica son compatibles entre los tres sistemas, siendo la prioridad de paquetes Linux &gt; macOS y en algunos casos, al final, Windows. 8.2 conda 101 conda info Actualizar conda conda update conda Listar todos los entornos de conda conda env list Actualizar todos los paquetes de conda (base) conda update conda --all Agregar canales conda config --add channels r conda config --add channels conda-forge conda config --add channels bioconda Buscar un paquete conda search PACKAGE Instalar un paquete en el entorno base conda install PACKAGE Eliminar archivos temporales conda clean --all -y Actualizar todos los paquetes del entorno actual conda update --all -y Eliminar entorno conda remove -n qiime2 --all Crear un entorno con versiones espec√≠ficas conda create -y -n test3.6 python=3.6 pandas=1.0 Crear entorno a partir de un archivo YAML conda env create -f environment.yml conda con vitaminas: mamba conda install -yc conda-forge mamba mamba create -y -n testpy3.6 python=3.6 pandas=1.0 mamba create -y -n testR3.6 r-base=3.6 "],["el-grupo-de-datos.html", "9 El grupo de datos", " 9 El grupo de datos M.C. Diana Oaxaca y Dra. Mirna Vazquez Rosas Landa 06 de agosto de 2025 9.0.1 Datos Los datos con los que trabajaremos se enlistan en la siguiente tabla. samples BioProject Article htn PRJEB13870 Gut microbiota dysbiosis contributes to ‚Ä¶ biogas PRJEB21678 Genetic repertoires of anaerobic microbiomes ‚Ä¶. pulque PRJNA603591 Genomic profiling of bacterial and fungal ‚Ä¶ sedimento PRJNA364776 Microbial Dark Matter project phase II * tea PRJNA698063 Niche differentiation of microbes‚Ä¶‚Ä¶) 9.0.1.1 htn Sinopsis: Se realiz√≥ secuenciaci√≥n metagen√≥mica de heces de pacientes sanos (control), con pre-hipertensi√≥n (pHTN) y con hipertensi√≥n (HTN). Los pacientes con enfermedad presentaron niveles de diversidad dr√°sticamente m√°s bajos en comparaci√≥n con el grupo control. Tambi√©n hicieron trasplantes fecales de pacientes enfermos a ratones ax√©nicos, el efecto del trasplante demostr√≥ que la hipertensi√≥n observada en los ratones era derivada de la microbiota trasplantada. Los datos crudos: PRJEB13870 https://www.ebi.ac.uk/ena/browser/view/PRJEB13870?show=reads El art√≠culo: Gut microbiota dysbiosis contributes to the development of hypertension sobre microbioma e hipertensi√≥n https://link.springer.com/article/10.1186/s40168-016-0222-x#Ack1 Li, J., Zhao, F., Wang, Y. et al.¬†Gut microbiota dysbiosis contributes to the development of hypertension. Microbiome 5, 14 (2017). https://doi.org/10.1186/s40168-016-0222-x 9.0.1.2 pulque. Sinopsis: En este trabajo se secuenciaron librerias de Illumina MiSeq de muestras a diferentes tiempos de fermentaci√≥n: 0 hrs (aguamiel), 3, 6 y 12 horas. En general observaron que la abundancia de los g√©neros cambi√≥ durante la fermentaci√≥n y se asoci√≥ con una disminuci√≥n de sacarosa, aumento de etanol y √°cido l√°ctico (Medidos por HPLC). Predijeron, entre otros, la bios√≠ntesis de folato y vitamina B. Uno de los MAG obtenidos correspondi√≥ a Saccharomyces cereviseae relacionado filogen√©ticamente con S. cerevisiae aislado de sake y bioetanol y otro correspondi√≥ a Zymomonas mobilis que propusieron como un nuevo linaje. Los datos crudos: PRJNA603591 https://www.ebi.ac.uk/ena/browser/view/PRJNA603591 El articulo: Genomic profiling of bacterial and fungal communities and their predictive functionality during pulque fermentation by whole-genome shotgun sequencing https://www.nature.com/articles/s41598-020-71864-4 Chac√≥n-Vargas, K., Torres, J., Giles-G√≥mez, M. et al.¬†Genomic profiling of bacterial and fungal communities and their predictive functionality during pulque fermentation by whole-genome shotgun sequencing. Sci Rep 10, 15115 (2020). https://doi.org/10.1038/s41598-020-71864-4 9.0.1.3 sedimento Microbioma de sedimento del Microbial Dark Matter project (MDMP) Sinopsis: El MDMP es realizado por el Departamento de Energ√≠a del JGI, se enfoca en resolver nuevos superphyla de bacterias y arqueas, en la fase uno se secuenciaron 201 linajes enriquecidos no cultivados, mediante single cell sequencing. En esta segunda fase se utilizaron datos p√∫blicos de diferentes muestras y regiones del mundo. A√∫n se siguen procesando datos y hasta el momento han encontrado prometedores SAGs inclu√≠do un phylum novedoso en Deward Creek. Los datos: PRJNA364776 https://www.ebi.ac.uk/ena/browser/view/PRJNA364776 El proyecto: Microbial Dark Matter project phaseII https://www.osti.gov/award-doi-service/biblio/10.46936/10.25585/60000876 Hedlund, Brian ORCID [1] Woyke, Tanja ORCID [2] Pester, Michael ORCID [3] Spear, John ORCID [4] Hallam, Steven ORCID [5] Eisen, Jonathan [6] Elshahed, Mostafa ORCID [7] Becraft, Eric [8] Dunfield, Peter [9] Teske, Andreas [10] van Heerden, et al.¬†Joint Genome Institute Award. 9.0.1.4 tea Microbioma de Camellia sinensis (la planta del t√© verde y negro) Sinopsis: En este trabajo se secuenciaron librerias de Illumina de muestras rizosf√©ricas y endof√≠ticas de C. sinensis, el estudio hace una descripci√≥n general de la taxonom√≠a y predicci√≥n funcional del microbioma, hace √©nfasis en las diferencias encontradas en la parte endof√≠tica y rizosf√©ricas. Los datos: PRJNA698063 https://www.ebi.ac.uk/ena/browser/view/PRJNA698063 El art√≠culo: Niche differentiation of microbes and their functional signatures in Assam type tea (Camellia sinensis var. assamica) https://www.researchsquare.com/article/rs-347764/v1 Bora, S. S., Dey, K. K., Borah, M., Rahman, M., Gogoi, M., Modi, M. K., &amp; Barooah, M. (2021). Niche differentiation of microbes and their functional signatures in Assam type tea (Camellia sinensis var. assamica). "],["mapeo-y-binning.html", "10 Mapeo y Binning 10.1 Secuenciaci√≥n 10.2 Control de calidad 10.3 Ensamble 10.4 Mapeo 10.5 Binning 10.6 Refinamiento", " 10 Mapeo y Binning M.C. Diana Oaxaca y Dra. Mirna Vazquez Rosas Landa 06 de agosto de 2025 10.1 Secuenciaci√≥n El ADN ambiental se secuencia utilizando alguna plataforma de secuenciacion o varias: Ilumina PacBio Nanopore 10.2 Control de calidad Del proceso de secuenciacion se recuperan lecturas de aproximadamente 300 bps. Las secuencias las recortamos para eliminar artefactos generados durante el proceso de secuenciaci√≥n. Aqu√≠ algunas herramientas utilizadas: FastQC Trimmomatic fastp 10.3 Ensamble Las lecturas se ensamblan para armar contigs y scaffolds. Existen diferentes programas para ensamblar metagenomas, aqu√≠ algunos de ellos: MEGAHIT IDBA MetaSPAdes 10.3.1 Discutamos https://docs.google.com/document/d/1iiw-q-90nATg-RNTd9nU8L1XE5xoDRC6j19JC1GiPIk/edit?usp=sharing 10.4 Mapeo Profundidad: La profundidad de cada contig se calcula mapeando las lecturas al ensamble. Este paso permite evaluar la calidad del ensable y es necesario para hacer la reconstrucci√≥n de genomas ya que, como veremos m√°s adelante, es uno de los par√°metros que toman en cuenta los ‚Äúbineadores‚Äù. Vamos a mapear utilizando la herramienta BBMap del programa BBtools. Y samtools. ¬°Manos a la obra! Con√©ctate al servidor: ssh USER@hpc-matematicas-z.fciencias.unam.mx Crea tu carpeta y una liga simb√≥lica a los datos: mkdir -p 01.Mapeo/{data,results} cd 01.Mapeo/ ln -s /home/diana/samples/htn/data/htn.fasta data/ ln -s /home/mirna/03.Mapeo/01.Trimm_reads/htn*.fastq data/ Primero, activa tu ambiente de conda. conda activate bbmap_env ¬°Ahora s√≠! Explora las opciones de bbmap, y vamos a hacer nuestro primer mapeo. bbmap.sh ref=data/htn.fasta in1=data/htn_1-short.fastq in2=data/htn_2-short.fastq out=results/htn.sam kfilter=22 subfilter=15 maxindel=80 cd results samtools view -bShu htn.sam | samtools sort -@ 94 -o htn_sorted.bam samtools index htn_sorted.bam 10.4.1 Discutamos https://docs.google.com/document/d/1iiw-q-90nATg-RNTd9nU8L1XE5xoDRC6j19JC1GiPIk/edit?usp=sharing 10.5 Binning Utilizaremos varios programas para hacer la reconstrucci√≥n de los genomas y haremos una comparaci√≥n de estos. NOTA: Cada programa tiene una ayuda y un manual de usuario, es importante revisarlo y conocer cada par√°metro que se ejecute. En terminal se puede consultar el manual con el comando man y tambi√©n se puede consultar la ayuda con -h o --help, por ejemplo fastqc -h. La presente pr√°ctica s√≥lo es una representaci√≥n del flujo de trabajo, sin embargo, no sustituye los manuales de cada programa y el flujo puede variar dependiendo del tipo de datos y pregunta de investigaci√≥n. 10.5.1 MaxBin Crea tu espacio de trabajo y una liga s√≠mb√≥lica hacia los datos que se usar√°n: mkdir -p 02.MaxBin/{data,results} cd 02.MaxBin/ ln -s /home/diana/samples/htn/data/htn.fasta data/ ln -s /home/diana/samples/htn/data/htn-depth.txt data/ Okay, ahora activa tu ambiente. conda activate maxbin_env Explora las opciones y ahora s√≠, a calcular bins. run_MaxBin.pl -contig data/htn.fasta -out results/maxbin -abund data/htn-depth.txt -max_iteration 2 10.5.2 MetaBat Okay vamos a utilizar otro progama. Crea tus ligas simb√≥licas :) mkdir -p 03.Metabat/{data,results} cd 03.Metabat/ ln -s /home/diana/samples/htn/data/htn.fasta data/ ln -s /home/diana/samples/htn/data/htn_sorted.bam data/ Para MetaBat lo primero que tenemos que hacer es crear un archivo de profundidad utilizando el script jgi_summarize_bam_contig_depths. Entonces, primero activamos el ambiente. conda activate metabat_env Como cualquier otro programa jgi_summarize_bam_contig_depths tiene opciones, podemos revisarlas. jgi_summarize_bam_contig_depths --outputDepth data/htn-depth.txt data/htn_sorted.bam Okay‚Ä¶ exploremos el archivo con head head data/htn-depth.txt Para metabat s√≥lo necesitamos dos archivos principales: El ensamble El archivo de profundidad metabat -i data/htn.fasta -a data/htn-depth.txt -o results/bins -t 4 --minCVSum 0 --saveCls -d -v --minCV 0.1 -m 2000 10.5.3 CONCOCT Okay, vamos a utilizar otro programa. Crea tus ligas simb√≥licas :) mkdir -p 04.Concoct/{data,results} cd 04.Concoct/ ln -s /home/diana/samples/htn/data/htn.fasta data/ ln -s /home/diana/samples/htn/data/htn_sorted.bam data/ Primero, activemos el ambiente conda activate concoct_env Primero, los contigs se tienen que partir en pedazos m√°s peque√±os cut_up_fasta.py data/htn.fasta -c 10000 -o 0 --merge_last -b results/SplitAssembly-htn.bed &gt; results/htn.fasta-split10K.fa Para crear la tabla de cobertura se necesita primero indexar el archivo bam samtools index data/htn_sorted.bam concoct_coverage_table.py results/SplitAssembly-htn.bed data/htn_sorted.bam &gt; results/concoct_coverage_table_htn.tsv ¬°Ahora s√≠! A correr concoct. Normalmente correr√≠amos 500 iteraciones, pero esta vez s√≥lo haremos una. concoct --coverage_file results/concoct_coverage_table_htn.tsv --composition_file results/htn.fasta-split10K.fa --clusters 400 --kmer_length 4 --threads 4 --length_threshold 3000 --basename concot --seed 4 --iterations 1 Combinar contigs merge_cutup_clustering.py concot_clustering_gt3000.csv &gt; results/merged-htn-gt3000.csv Extraer bins como fasta individualmente mkdir results/bins-concot extract_fasta_bins.py data/htn.fasta results/merged-htn-gt3000.csv --output_path results/bins-concot 10.5.4 Discutamos https://docs.google.com/document/d/1iiw-q-90nATg-RNTd9nU8L1XE5xoDRC6j19JC1GiPIk/edit?usp=sharing 10.6 Refinamiento 10.6.1 DASTool Preparing input files. Fasta_to_Scaffolds2Bin.sh -i /home/mirna/05.Concoct/bins-concot -e fa &gt; htn_concot.scaffolds2bin.tsv Fasta_to_Scaffolds2Bin.sh -i /home/mirna/04.Metabat2 -e fa &gt; htn.scaffolds2bin.tsv PATH=/home/programs:$PATH /home/programs/DAS_Tool-1.1.2/DAS_Tool -i htn_maxbin.contigs2bin.tsv,htn_metabat.scaffolds2bin.tsv,htn_concoct.scaffolds2bin.tsv -l maxbin,metabat,concoct -c data/htn.fasta -o results/htn_bins --debug -t 4 --search_engine diamond --write_bins 1 10.6.2 CheckM Muy bien, crea un nuevo directorio y entra en √©l. mkdir 06.CheckM cd 06.CheckM/ Ahora activemos el ambiente. conda activate checkm_env checkm lineage_wf -t 4 -x fa /home/mirna/05.DAS_tool/results/htn_bins_DASTool_bins DAStools-log_htn -f CheckM-DAS_Tool_bins.txt Vamos a explorar la salida de checkM Primero me puedes decir ¬øCu√°ntas lineas tiene tu archivo? Okay‚Ä¶ ahora vamos a remover esas lineas feas. sed -e &#39;1,3d&#39; CheckM-DAS_Tool_bins.txt | sed -e &#39;37d&#39; &gt;CheckM-DAS_Tool_bins_mod.txt library(tidyverse) # CheckM -------------------------------------------------------------------#### checkm&lt;-read.table(&quot;CheckM-DAS_Tool_bins_mod.txt&quot;, sep = &quot;&quot;, header = F, na.strings =&quot;&quot;, stringsAsFactors= F) # Extracting good quality bins Megahit ------------------------------------#### colnames(checkm)&lt;-c(&quot;Bin_Id&quot;, &quot;Marker&quot;, &quot;lineage&quot;, &quot;Number_of_genomes&quot;, &quot;Number_of_markers&quot;, &quot;Number_of_marker_sets&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;Completeness&quot;, &quot;Contamination&quot;, &quot;Strain_heterogeneity&quot;) good_bins&lt;-checkm %&gt;% select(Bin_Id, Marker, Completeness, Contamination) %&gt;% filter(Completeness &gt;= 50.00) %&gt;% filter(Contamination &lt;= 10.00) Okay‚Ä¶ quiz√° podamos recuperar algunos m√°s. medium_bins&lt;-checkm %&gt;% select(Bin_Id, Marker, Completeness, Contamination) %&gt;% filter(Completeness &gt;= 50.00) %&gt;% filter(Contamination &lt;= 20.00) Muy bien, vamos a extraer esos bins. bins&lt;-medium_bins$Bin_Id write.table(bins, &quot;lista_medium_bins&quot;, quote = F, row.names = F, col.names = F) 10.6.3 Mis Bins mkdir -p 08.Bins/{Genoma,Proteoma} cd 08.Bins sed &#39;s#bin#cp /home/mirna/05.DAS_tool/results/htn_bins_DASTool_bins/bin#g&#39; lista_medium_bins | sed &#39;s#$#.fa .#g&#39; &gt; copy_bins.sh Ahora un ejercicio. grep &quot;&gt;&quot; *.fa ¬øCu√°l es el problema? change_bin_name&lt;-function(ruta, ambiente){ ruta_original&lt;-getwd() setwd(ruta) filez &lt;- list.files() newname&lt;-paste0(ambiente, &quot;_&quot;, filez) file.rename(from=filez, to=newname) filez &lt;- list.files() file.rename(from=filez, to=sub(pattern=&quot;\\\\.&quot;, replacement=&quot;_&quot;, filez)) setwd(ruta_original) } change_bin_name(&quot;/home/mirna/07.Bins/Genoma&quot;, &quot;htn&quot;) library(phylotools) library(tidyverse) add_names_to_seqs &lt;- function(nombre_del_archivo){ filenames &lt;- unlist(strsplit(nombre_del_archivo, &quot;/&quot;)) filenames &lt;- filenames[[grep(&quot;fa&quot;, filenames)]] divide &lt;- unlist(strsplit(filenames, &quot;\\\\.&quot;)) bin_name &lt;- divide[1] termination &lt;- divide[2] old_name &lt;- get.fasta.name(nombre_del_archivo) new_name &lt;- paste0( bin_name, &quot;-scaffold-&quot;, old_name) ref2 &lt;- data.frame(old_name, new_name) out_file &lt;- paste0(bin_name, &quot;_renamed&quot;, &quot;.&quot;, termination) rename.fasta(infile = nombre_del_archivo, ref_table = ref2, outfile = out_file) } files &lt;- list.files(&quot;.&quot;) files &lt;- paste0(&quot;/home/mirna/07.Bins/Genoma/&quot;, files) map(files, add_names_to_seqs) Veamos si funcion√≥ grep &quot;&gt;&quot; *.fa Muy bien, pongamos eso en una nueva carpeta y esperemos lo mejor jaja. No es cierto, s√≠ mov√°moslo a otra carpeta, pero quitemos el renamed. change_bin_name&lt;-function(ruta){ ruta_original&lt;-getwd() setwd(ruta) filez &lt;- list.files() file.rename(from=filez, to=sub(pattern=&quot;_renamed&quot;, replacement=&quot;&quot;, filez)) setwd(ruta_original) } change_bin_name(&quot;/home/mirna/07.Bins/Genoma/01.Bins_named&quot;) ¬øCreen que puedan optimizar esos scripts? ¬°Discute en tu equipo si tienes una mejor idea! "],["asignaci√≥n-taxon√≥mica.html", "11 Asignaci√≥n taxon√≥mica 11.1 Leamos los datos", " 11 Asignaci√≥n taxon√≥mica Dra. Mirna Vazquez Rosas Landa 06 de agosto de 2025 Vamos a explorar la taxonom√≠a de estos bins con GTDB-tk. mkdir 11.GTDBTK Activemos el ambiente conda activate gtdbtk-2.1.0 Indiquemos d√≥nde est√° la base de datos: export GTDBTK_DATA_PATH=/home/programs/DB/release207_v2 Explora la ayuda de GTDB-tk Discutamos: https://docs.google.com/document/d/1iiw-q-90nATg-RNTd9nU8L1XE5xoDRC6j19JC1GiPIk/edit?usp=sharing Excelente, ahora en equipos vamos a correr GTDB-tk. gtdbtk classify_wf --genome_dir /home/mirna/07.Bins/Genoma/01.Bins_named --out_dir /home/mirna/11.GTDBTK --cpus 4 -x fa Vamos a visualizar los datos. Todos a R!! 11.1 Leamos los datos library(tidyverse) GTDBK&lt;-read.table(&quot;11.GTDBTK/gtdbtk.bac120.summary.tsv&quot;, sep = &quot;\\t&quot;, header = T, na.strings =&quot;&quot;, stringsAsFactors= F)%&gt;% as_tibble() htn_gtdbtk&lt;-GTDBK %&gt;% select(user_genome, classification) %&gt;% separate(classification, c(&quot;Domain&quot;, &quot;Phylum&quot;, &quot;Class&quot;, &quot;Order&quot;, &quot;Family&quot;, &quot;Genus&quot;, &quot;Species&quot;), sep= &quot;;&quot;) %&gt;% rename(Bin_name=user_genome) %&gt;% unite(Bin_name_2, c(&quot;Bin_name&quot;, &quot;Phylum&quot;), remove = FALSE) %&gt;% select(Bin_name, Domain, Phylum, Class, Order, Family, Genus, Species) Par√©ntesis, vamos a imprimir esta tabla para convertirla en metadatos. write.table(htn_gtdbtk, file = &quot;11.GTDBTK/Metadatos.txt&quot;, sep=&quot;\\t&quot;, quote = F, row.names = F, col.names = T) Vamos a hacer un plot GTDBtk&lt;-htn_gtdbtk %&gt;% count(Domain, Phylum) %&gt;% rename(Number_of_MAGs = n) %&gt;% ggplot(aes(x = Domain, y = Number_of_MAGs, fill = Phylum)) + geom_bar(stat = &quot;identity&quot;, position=position_dodge())+ theme_minimal() Puede ser interactivo tambi√©n. library(plotly) GTDBtk_p_fig &lt;- ggplotly(GTDBtk) "],["inferencia-metab√≥lica.html", "12 Inferencia metab√≥lica 12.1 KEEG 12.2 Explorando el metabolismo con rbims. 12.3 Anotaci√≥n con InterproScan", " 12 Inferencia metab√≥lica Dra. Mirna Vazquez Rosas Landa 07 de agosto de 2025 Vamos a utilizar prodigal para predecir las prote√≠nas: for i in /home/mirna/07.Bins/Genoma/01.Bins_named/*.fa ; do prodigal -i $i -o $i.txt -a $i.faa ; done Veamos un poco la salida grep &quot;&gt;&quot; *.faa 12.1 KEEG Okay, ahora vamos a utilizar kofam_scan para anotar las prote√≠nas. Vamos a dividirnos en equipos para hacer la anotaci√≥n de los bins! Esto es como lo har√≠amos para uno: /home/programs/DB/kofam/kofam_scan-1.3.0/exec_annotation -o /home/mirna/08.Kofamscan/htn_bins_63.fa.faa.txt /home/mirna/07.Bins/Proteoma/htn_bins_63.fa.faa --report-unannotated --cpu 4 En un loop lo podr√≠amos hacer as√≠: for i in *.faa ; do /home/programs/DB/kofam/kofam_scan-1.3.0/exec_annotation -o /home/mirna/08.Kofamscan/$i.txt $i --report-unannotated --cpu 4; done Okay antes de correrlo, vamos a crear dos carpetas nuevas y unas ligas simb√≥licas. mkdir -p 08.Kofamscan/{01.Proteomas,02.KO_results} cd 08.Kofamscan/ ln -s /home/mirna/07.Bins/Proteoma/*.faa 01.Proteomas Ajusta el loop para correr KofamScan con los genomas que te tocan :) 12.2 Explorando el metabolismo con rbims. Vamos a hacer una exploraci√≥n r√°pida del metabolismo con rbims. Okay iniciamos con la librer√≠a de Rbims library(rbims) library(tidyverse) Ahora, vamos a leer los resultados de KEEG y mapearlos con el resto de la base de datos de KEEG htn_mapp&lt;-read_ko(&quot;08.Kofamscan/02.KO_results/&quot;) %&gt;% mapping_ko() Okay, vamos a enfocarnos en los metabolismos encargados de la obtenci√≥n de energ√≠a. Overview&lt;-c(&quot;Central Metabolism&quot;, &quot;Carbon Fixation&quot;, &quot;Nitrogen Metabolism&quot;, &quot;Sulfur Metabolism&quot;, &quot;Fermentation&quot;, &quot;Methane Metabolism&quot;) Energy_metabolisms_htn&lt;-htn_mapp %&gt;% drop_na(Cycle) %&gt;% get_subset_pathway(rbims_pathway, Overview) Vamos a visualizar los datos. plot_bubble(tibble_ko = Energy_metabolisms_htn, x_axis = Bin_name, y_axis = Pathway_cycle, analysis=&quot;KEGG&quot;, calc=&quot;Percentage&quot;, range_size = c(1,10), y_labs=FALSE, x_labs=FALSE) Okay, incorporemos metadatos, por ejemplo la taxonom√≠a. Metadatos&lt;-read_delim(&quot;11.GTDBTK/Metadatos.txt&quot;, delim=&quot;\\t&quot;) Hagamos un plot plot_bubble(tibble_ko = Energy_metabolisms_htn, x_axis = Bin_name, y_axis = Pathway_cycle, analysis=&quot;KEGG&quot;, data_experiment = Metadatos, calc=&quot;Percentage&quot;, color_character = Class, range_size = c(1,10), y_labs=FALSE, x_labs=FALSE) Ahora, vamos a explorar una sola v√≠a Secretion_system_htn&lt;-htn_mapp %&gt;% drop_na(Cycle) %&gt;% get_subset_pathway(Cycle, &quot;Secretion system&quot;) Y hagamos un heatmap plot_heatmap(tibble_ko=Secretion_system_htn, y_axis=Genes, analysis = &quot;KEGG&quot;, calc=&quot;Binary&quot;) Ahora agreguemos metadatos plot_heatmap(tibble_ko=Secretion_system_htn, y_axis=Genes, data_experiment = Metadatos, order_x = Phylum, analysis = &quot;KEGG&quot;, calc=&quot;Binary&quot;) plot_heatmap(tibble_ko=Secretion_system_htn, y_axis=Genes, data_experiment = Metadatos, order_y = Pathway_cycle, order_x = Phylum, analysis = &quot;KEGG&quot;, calc=&quot;Binary&quot;) 12.3 Anotaci√≥n con InterproScan for i in $(ls *.faa); do sed -i &quot;s/\\*//g&quot; $i; done for i in $(ls *.faa); do interproscan.sh -cpu 4 -goterms -pa -i $i &gt; Log_Interpro_Scan_$i.txt; done Okay‚Ä¶ vamos a juntar todo en un solo. cat *.tsv &gt; htn_interpro.tsv Vamos a R library(rbims) library(tidyverse) interpro_Interpro_profile&lt;-read_interpro( data_interpro = &quot;09.Interpro/01.Proteomas/htn_interpro.tsv&quot;, database=&quot;INTERPRO&quot;, profile = T) %&gt;% filter(!str_detect(INTERPRO, &quot;-&quot;)) important_INTERPRO&lt;-get_subset_pca(tibble_rbims=interpro_Interpro_profile, cos2_val=0.95, analysis=&quot;INTERPRO&quot;) plot_heatmap(important_INTERPRO, y_axis=INTERPRO, analysis = &quot;INTERPRO&quot;, distance = T) plot_heatmap(important_INTERPRO, y_axis=INTERPRO, analysis = &quot;INTERPRO&quot;, distance = F) 12.3.1 Finalmente podemos escribir esto en una tabla. write_metabolism(&quot;09.Interpro/01.Proteomas/htn_interpro.tsv&quot;, &quot;08.Kofamscan/02.KO_results/&quot;) "],["proyectos-colaborativos-1.html", "13 Proyectos colaborativos 13.1 Propuesta 1 13.2 Propuesta 2 13.3 Propuesta 3 13.4 Propuesta 4 13.5 Propuesta 5", " 13 Proyectos colaborativos 13.1 Propuesta 1 13.2 Propuesta 2 13.3 Propuesta 3 13.4 Propuesta 4 13.5 Propuesta 5 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
